/**
 * Malware Detection Feature
 *
 * Provides comprehensive malware, virus, spyware, and malicious code
 * detection capabilities for the oh-my-claude system.
 *
 * Features:
 * - Pattern-based threat detection
 * - Supply chain risk analysis
 * - Behavioral analysis
 * - Risk scoring
 * - Detailed reporting
 */

export * from './types.js';
export * from './patterns.js';

import type { ThreatPattern, ThreatMatch, ScanResult, ThreatSeverity } from './types.js';
import { allPatterns, typosquatPatterns, suspiciousScripts } from './patterns.js';

/**
 * Calculate risk score based on threats found
 */
export function calculateRiskScore(threats: ThreatMatch[]): number {
  const severityWeights: Record<ThreatSeverity, number> = {
    CRITICAL: 30,
    HIGH: 20,
    MEDIUM: 10,
    LOW: 3,
    INFO: 1,
  };

  let score = 0;
  for (const threat of threats) {
    score += severityWeights[threat.pattern.severity];
  }

  // Cap at 100
  return Math.min(100, score);
}

/**
 * Determine verdict based on risk score
 */
export function getVerdict(riskScore: number): 'CLEAN' | 'SUSPICIOUS' | 'INFECTED' {
  if (riskScore >= 70) return 'INFECTED';
  if (riskScore >= 30) return 'SUSPICIOUS';
  return 'CLEAN';
}

/**
 * Get threat summary counts
 */
export function getThreatSummary(threats: ThreatMatch[]): {
  critical: number;
  high: number;
  medium: number;
  low: number;
} {
  return {
    critical: threats.filter((t) => t.pattern.severity === 'CRITICAL').length,
    high: threats.filter((t) => t.pattern.severity === 'HIGH').length,
    medium: threats.filter((t) => t.pattern.severity === 'MEDIUM').length,
    low: threats.filter((t) => t.pattern.severity === 'LOW' || t.pattern.severity === 'INFO').length,
  };
}

/**
 * Check if a package name might be typosquatted
 */
export function checkTyposquatting(packageName: string): boolean {
  const lowerName = packageName.toLowerCase();
  return typosquatPatterns.some((pattern) => lowerName.includes(pattern));
}

/**
 * Check if a script is suspicious
 */
export function isSuspiciousScript(script: string): boolean {
  return suspiciousScripts.some((pattern) => pattern.test(script));
}

/**
 * Format a scan result as markdown report
 */
export function formatScanReport(result: ScanResult): string {
  const lines: string[] = [
    '# Malware Scan Report',
    '',
    `**Scanned:** ${result.targetPath}`,
    `**Date:** ${result.scannedAt.toISOString()}`,
    `**Risk Score:** ${result.riskScore}/100 - ${result.verdict}`,
    '',
    '## Executive Summary',
    `- **Threats Detected:** ${result.threats.length}`,
    `- **Critical Issues:** ${result.summary.critical}`,
    `- **High Issues:** ${result.summary.high}`,
    `- **Medium Issues:** ${result.summary.medium}`,
    `- **Low Issues:** ${result.summary.low}`,
    `- **Files Analyzed:** ${result.filesScanned}`,
    `- **Verdict:** ${result.verdict}`,
    '',
  ];

  if (result.threats.length === 0) {
    lines.push('## Result');
    lines.push('');
    lines.push('No malicious patterns detected. Codebase appears clean.');
    lines.push('');
  } else {
    // Group threats by severity
    const criticalThreats = result.threats.filter((t) => t.pattern.severity === 'CRITICAL');
    const highThreats = result.threats.filter((t) => t.pattern.severity === 'HIGH');
    const mediumThreats = result.threats.filter((t) => t.pattern.severity === 'MEDIUM');
    const lowThreats = result.threats.filter(
      (t) => t.pattern.severity === 'LOW' || t.pattern.severity === 'INFO'
    );

    if (criticalThreats.length > 0) {
      lines.push('## Critical Threats (Immediate Action Required)');
      lines.push('');
      for (const threat of criticalThreats) {
        lines.push(`### ${threat.pattern.name}`);
        lines.push(`**Type:** ${threat.pattern.category}`);
        lines.push(`**Severity:** CRITICAL`);
        lines.push(`**Location:** \`${threat.file}:${threat.line}\``);
        lines.push(`**Description:** ${threat.pattern.description}`);
        lines.push('**Evidence:**');
        lines.push('```');
        lines.push(threat.content.trim());
        lines.push('```');
        if (threat.pattern.falsePositiveHint) {
          lines.push(`**Note:** ${threat.pattern.falsePositiveHint}`);
        }
        lines.push('');
      }
    }

    if (highThreats.length > 0) {
      lines.push('## High Severity Threats');
      lines.push('');
      for (const threat of highThreats) {
        lines.push(`### ${threat.pattern.name}`);
        lines.push(`**Type:** ${threat.pattern.category} | **Location:** \`${threat.file}:${threat.line}\``);
        lines.push(`**Description:** ${threat.pattern.description}`);
        if (threat.pattern.falsePositiveHint) {
          lines.push(`**Note:** ${threat.pattern.falsePositiveHint}`);
        }
        lines.push('');
      }
    }

    if (mediumThreats.length > 0) {
      lines.push('## Medium Severity Threats');
      lines.push('');
      for (const threat of mediumThreats) {
        lines.push(`- **${threat.pattern.name}** at \`${threat.file}:${threat.line}\` - ${threat.pattern.description}`);
      }
      lines.push('');
    }

    if (lowThreats.length > 0) {
      lines.push('## Low Severity / Informational');
      lines.push('');
      lines.push(`${lowThreats.length} low-severity patterns detected. These are generally safe but worth monitoring.`);
      lines.push('');
    }
  }

  lines.push('## Recommendations');
  lines.push('');
  if (result.verdict === 'INFECTED') {
    lines.push('1. **CRITICAL:** Isolate this code immediately');
    lines.push('2. **DO NOT** deploy to production');
    lines.push('3. Investigate the source of malicious code');
    lines.push('4. Consider reporting to security team');
    lines.push('5. Review git history for when malicious code was introduced');
  } else if (result.verdict === 'SUSPICIOUS') {
    lines.push('1. Review all flagged patterns manually');
    lines.push('2. Verify the legitimacy of suspicious code');
    lines.push('3. Run additional security scans');
    lines.push('4. Consider code review before deployment');
  } else {
    lines.push('1. Continue regular security practices');
    lines.push('2. Keep dependencies updated');
    lines.push('3. Run periodic security audits');
  }
  lines.push('');

  return lines.join('\n');
}

/**
 * Get patterns by severity level
 */
export function getPatternsBySeverity(severity: ThreatSeverity): ThreatPattern[] {
  return allPatterns.filter((p) => p.severity === severity);
}

/**
 * Get all available patterns
 */
export function getAllPatterns(): ThreatPattern[] {
  return allPatterns;
}
